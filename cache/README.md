# 缓存一致性解决方案 

## 先删缓存再添加数据库

**执行步骤**

修改操作：

1. 删除缓存 u1
2. 修改数据库 u2
3. 提交事务 u3

查询操作：

1. 查询缓存 c1
2. 放入缓存 c2

缺陷情况:

u1->c1->c2->u2  造成旧数据进缓存

## 先添加数据库再删缓存[同事务]

**执行步骤**

修改操作：

1. 修改数据库 u1
2. 删除缓存 u2
3. 提交事务 u3

查询操作：

1. 查询缓存 c1
2. 放入缓存 c2

缺陷情况：

u1 -> u2 -> c1-> c2 根据MVCC机制查询到旧数据放入缓存

## 先添加数据库再删缓存[不同事务]

**执行步骤**

修改操作：

1. 修改数据库 u1
2. 提交事务 u2
3. 删除缓存 u3

查询操作：

1. 查询缓存 c1
2. 放入缓存 c2

缺陷情况：

u1 -> u3[失败] 造成c1查询到旧缓存

## 先添加数据库查询删除情况再删缓存

**执行步骤**

修改操作：

1. 修改数据库 u1
2. 提交事务 u2
3. 删除缓存 u3
4. 等待获取redis返回删除条数 u4
5. 上一步如果失败则回退事务

查询操作：

1. 查询缓存 c1
2. 放入缓存 c2

缺陷情况：

手工代码过多，需要因为缓存问题写回退方法[回退过程可能导致更多问题，究极不建议！]

## 消息队列异步处理

**执行步骤**

修改操作：

1. 修改数据库 u1
2. 消息队列[消息]删除缓存 u2
3. 提交事务 u3
   - 消息队列异步消费消息 u4

查询操作：

1. 查询缓存 c1
2. 查询DB,放入缓存 c2

缺陷情况：

u1->u2->c1  造成旧数据进缓存[u3还没执行]

u1->u3->u4[失败]->c1->c2 [但是消息最终会消费保证一致]  

## 消息队列同步消息处理

**执行步骤**

修改操作：

1. 修改数据库 u1
2. 消息队列[同步消息]删除缓存 u2
3. 提交事务 u3
   - 消息队列同步消费消息 u4

查询操作：

1. 查询缓存 c1
2. 查询DB,放入缓存 c2

缺陷情况：

无，吞吐量巨幅下降

## 消息队列消息处理

**执行步骤**

修改操作：

1. 消息队列[顺序消息A] u1
   - 删除缓存 u2
   - 修改数据库 u3
2. 提交事务 u4

查询操作：

1. 查询缓存 c1
2. 消息队列[顺序消息A压栈刷新缓存] c2
3. 查询缓存 c3[循环查询缓存]
4. 超时查询DB c4

缺陷情况：

u4删除缓存失败

可能会重复消息队列刷新缓存->用redis控制上一个操作状态进行过滤[zk存在并发写瓶颈]

## 内存队列消息处理

**执行步骤**

初始化:

1. 系统初始化1个线程池 每个线程把控一个内存队列

修改操作：

1. 根据hash规则入队列 u1

   - 修改数据库 u2

   - 删除，并设置flag u3

2. 提交事务 u4

查询操作：

1. 查询缓存 c1 [循环查询]
2. 根据hash规则入队列 c2
   - 根据上一个flag状态、查询DB、刷新缓存 c3
3. 超时查询DB c4

缺陷情况：

无
